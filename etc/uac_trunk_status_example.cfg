#!
# Minimal example: centralized trunk status using event_route[uac:reply]
#
# Load needed modules in your kamailio.cfg as usual:
#   loadmodule "tm.so"
#   modparam("tm", "enable_uac_fr", 1)
#   loadmodule "uac.so"
#   loadmodule "htable.so"
#   modparam("htable", "htable", "trunks=>size=8;autoexpire=0")
#
# Optional: set a KEMI callback for events instead of native event_route
#   modparam("uac", "event_callback", "ksr_uac_event")
#   (this sample uses native event_route)

#
# Route to send an OPTIONS probe for a given trunk target.
# Use $uac_req(l_uuid) to tag the trunk identifier so it arrives in the event.
# Set evroute=2 so branch failures/timeouts also trigger the event.
#
route[TRUNK_PING] {
    # Inputs:
    #   $var(tid)  - trunk id (string)
    #   $var(ruri) - R-URI to probe, e.g., "sip:gw1.example.net"
    #   $var(from) - From URI, e.g., "sip:monitor@yourdomain"

    $uac_req(all) = $null;
    $uac_req(method) = "OPTIONS";
    $uac_req(ruri) = $var(ruri);
    $uac_req(turi) = $var(ruri);
    $uac_req(furi) = $var(from);
    $uac_req(callid) = $(mb{s.md5});

    # tag the trunk id; mirrored into $uac_req(evparam) for compatibility
    $uac_req(l_uuid) = $var(tid);

    # execute event on branch final reply and failures (needs tm.enable_uac_fr=1)
    $uac_req(evroute) = 2;

    if(!uac_req_send()) {
        xlog("L_ERR", "UAC send failed for trunk=[$var(tid)] ruri=[$var(ruri)]\n");
    }
}

#
# Centralized status sink for all UAC traffic (probes and uac_reg REGISTERs).
# Stores a compact JSON in htable:trunks keyed by $uac_req(l_uuid) or evparam.
#
event_route[uac:reply] {
    # pick a trunk key (prefer l_uuid; fallback to evparam; finally callid)
    if($uac_req(l_uuid) != $null) {
        $var(key) = $uac_req(l_uuid);
    } else if($uac_req(evparam) != $null) {
        $var(key) = $uac_req(evparam);
    } else {
        $var(key) = $uac_req(callid);
    }

    # Normalize values
    if($uac_req(evreason) == $null) $uac_req(evreason) = "";

    # Build a compact JSON snapshot; escape reason
    $var(js) = "{\"code\":" $+ $uac_req(evcode) $+
               ",\"icode\":" $+ $uac_req(evicode) $+
               ",\"type\":" $+ $uac_req(evtype) $+
               ",\"time\":" $+ $TS $+
               ",\"reason\":\"" $+
               $(uac_req(evreason){s.escape.common}) $+
               "\"}";

    # Persist to htable
    $sht(trunks=>$var(key)) = $var(js);

    xlog("L_INFO", "TRUNK-STATUS key=[$var(key)] js=[$var(js)]\n");
}

#
# Example of using the status (read back from shared htable)
#
route[CHECK_TRUNK] {
    # Input: $var(tid)
    if($sht(trunks=>$var(tid)) != $null) {
        xlog("L_INFO", "Trunk [$var(tid)] status: $sht(trunks=>$var(tid))\n");
    } else {
        xlog("L_INFO", "Trunk [$var(tid)] has no status yet\n");
    }
}

